{"title":"","type":"page","uid":"1cd19fc71517798e2fa5b7457d1fb06e","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The ...","date":"2023-09-18T09:42:52.180Z","updated":"2023-09-18T09:42:52.180Z","comments":true,"path":"api/pages/photos/ins.js","covers":[],"content":"/******/\n(function(modules) { // webpackBootstrap\n  /******/ // The module cache\n  /******/\n  var installedModules = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __webpack_require__(moduleId) {\n    /******/\n    /******/ // Check if module is in cache\n    /******/\n    if (installedModules[moduleId])\n      /******/\n      return installedModules[moduleId].exports;\n    /******/\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = installedModules[moduleId] = {\n      /******/\n      exports: {},\n      /******/\n      id: moduleId,\n      /******/\n      loaded: false\n      /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n    /******/ // Flag the module as loaded\n    /******/\n    module.loaded = true;\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /******/\n  /******/ // expose the modules object (__webpack_modules__)\n  /******/\n  __webpack_require__.m = modules;\n  /******/\n  /******/ // expose the module cache\n  /******/\n  __webpack_require__.c = installedModules;\n  /******/\n  /******/ // __webpack_public_path__\n  /******/\n  __webpack_require__.p = \"/dist/\";\n  /******/\n  /******/ // Load entry module and return exports\n  /******/\n  return __webpack_require__(0);\n  /******/\n})\n  /************************************************************************/\n  /******/\n  ([\n    /* 0 */\n    /***/\n    function(module, exports, __webpack_require__) {\n\n      'use strict';\n\n      __webpack_require__(1);\n\n      var _view = __webpack_require__(2);\n\n      var _view2 = _interopRequireDefault(_view);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      /**\n       * @name impush-client\n       * @description 这个项目让我发家致富…\n       * @date 2016-12-1\n       */\n\n      var _collection = [];\n      var _count = 0;\n      var searchData;\n\n      function addMask(elem) {\n        var rect = elem.getBoundingClientRect();\n        var style = getComputedStyle(elem, null);\n\n        var mask = document.createElement('i');\n        mask.className = 'icon-film';\n        mask.style.color = '#fff';\n        mask.style.fontSize = '26px';\n        mask.style.position = 'absolute';\n        mask.style.left = '10px';\n        mask.style.top = '10px';\n        mask.style.zIndex = 1;\n        elem.parentNode.appendChild(mask);\n      }\n\n      var createVideoIncon = function createVideoIncon() {\n        var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]');\n        for (var i = 0, len = $videoImg.length; i < len; i++) {\n          addMask($videoImg[i]);\n        }\n      };\n      var render = function render(res) {\n        var ulTmpl = \"\";\n        for (var j = 0, len2 = res.list.length; j < len2; j++) {\n          var data = res.list[j].arr;\n          var liTmpl = \"\";\n          for (var i = 0, len = data.link.length; i < len; i++) {\n\n            var minSrc = '/assets/camera/camera' + data.link[i] + '.jpg';\n            var src = '/assets/camera/camera' + data.link[i];\n            var type = data.type[i];\n            var target = src + (type === 'video' ? '.mp4' : '.jpg');\n            src += '.jpg';\n\n            liTmpl += '<figure style=\"overflow: hidden;\" class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\">\\\n                <a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"640x640\" data-type=\"' + type + '\" data-target=\"' + target + '\">\\\n                  <img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"/assets/user/empty.png\" itemprop=\"thumbnail\" onload=\"lzld(this)\">\\\n                </a>\\\n                <figcaption style=\"display:none\" itemprop=\"caption description\">' + data.text[i] + '</figcaption>\\\n            </figure>';\n          }\n          ulTmpl = ulTmpl + '<section class=\"archives album\"><h1 class=\"year\">' + data.year + '<em>' + data.month + '月</em></h1>\\\n        <ul class=\"img-box-ul\" style=\"overflow: hidden;\">' + liTmpl + '</ul>\\\n        </section>';\n        }\n        document.querySelector('.instagram').innerHTML = '<div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\">' + ulTmpl + '</div>';\n        createVideoIncon();\n        _view2.default.init();\n      };\n\n      var replacer = function replacer(str) {\n        var arr = str.split(\"/\");\n        return \"/assets/ins/\" + arr[arr.length - 1];\n      };\n\n      var ctrler = function ctrler(data) {\n        var imgObj = {};\n        for (var i = 0, len = data.length; i < len; i++) {\n          var y = data[i].y;\n          var m = data[i].m;\n          var src = replacer(data[i].src);\n          var text = data[i].text;\n          var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m);\n          if (imgObj[key]) {\n            imgObj[key].srclist.push(src);\n            imgObj[key].text.push(text);\n          } else {\n            imgObj[key] = {\n              year: y,\n              month: m,\n              srclist: [src],\n              text: [text]\n            };\n          }\n        }\n        render(imgObj);\n      };\n\n      function loadData(success) {\n        if (!searchData) {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', './ins.json?t=' + +new Date(), true);\n\n          xhr.onload = function() {\n            if (this.status >= 200 && this.status < 300) {\n              var res = JSON.parse(this.response);\n              searchData = res;\n              success(searchData);\n            } else {\n              console.error(this.statusText);\n            }\n          };\n\n          xhr.onerror = function() {\n            console.error(this.statusText);\n          };\n\n          xhr.send();\n        } else {\n          success(searchData);\n        }\n      }\n\n      var Ins = {\n        init: function init() {\n          loadData(function(data) {\n            render(data);\n          });\n        }\n      };\n\n      Ins.init();\n\n      // export default impush;\n\n      /***/\n    },\n    /* 1 */\n    /***/\n    function(module, exports, __webpack_require__) {\n\n      /* WEBPACK VAR INJECTION */\n      (function(global) {\n        'use strict';\n\n        var inViewport = __webpack_require__(3);\n        var lazyAttrs = ['data-src'];\n\n        global.lzld = lazyload();\n\n        // Provide libs using getAttribute early to get the good src\n        // and not the fake data-src\n        replaceGetAttribute('Image');\n        replaceGetAttribute('IFrame');\n\n        function registerLazyAttr(attr) {\n          if (indexOf.call(lazyAttrs, attr) === -1) {\n            lazyAttrs.push(attr);\n          }\n        }\n\n        function lazyload(opts) {\n          opts = merge({\n            'offset': 333,\n            'src': 'data-src',\n            'container': false\n          }, opts || {});\n\n          if (typeof opts.src === 'string') {\n            registerLazyAttr(opts.src);\n          }\n\n          var elts = [];\n\n          function show(elt) {\n            var src = findRealSrc(elt);\n\n            if (src) {\n              elt.src = src;\n            }\n\n            elt.setAttribute('data-lzled', true);\n            elts[indexOf.call(elts, elt)] = null;\n          }\n\n          function findRealSrc(elt) {\n            if (typeof opts.src === 'function') {\n              return opts.src(elt);\n            }\n\n            return elt.getAttribute(opts.src);\n          }\n\n          function register(elt) {\n            elt.onload = null;\n            elt.removeAttribute('onload');\n            elt.onerror = null;\n            elt.removeAttribute('onerror');\n\n            if (indexOf.call(elts, elt) === -1) {\n              inViewport(elt, opts, show);\n            }\n          }\n\n          return register;\n        }\n\n        function replaceGetAttribute(elementName) {\n          var fullname = 'HTML' + elementName + 'Element';\n          if (fullname in global === false) {\n            return;\n          }\n\n          var original = global[fullname].prototype.getAttribute;\n          global[fullname].prototype.getAttribute = function(name) {\n            if (name === 'src') {\n              var realSrc;\n              for (var i = 0, max = lazyAttrs.length; i < max; i++) {\n                realSrc = original.call(this, lazyAttrs[i]);\n                if (realSrc) {\n                  break;\n                }\n              }\n\n              return realSrc || original.call(this, name);\n            }\n\n            // our own lazyloader will go through theses lines\n            // because we use getAttribute(opts.src)\n            return original.call(this, name);\n          };\n        }\n\n        function merge(defaults, opts) {\n          for (var name in defaults) {\n            if (opts[name] === undefined) {\n              opts[name] = defaults[name];\n            }\n          }\n\n          return opts;\n        }\n\n        // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html\n        function indexOf(value) {\n          for (var i = this.length; i-- && this[i] !== value;) {}\n          return i;\n        }\n\n        module.exports = lazyload;\n\n        // export default impush;\n        /* WEBPACK VAR INJECTION */\n      }.call(exports, (function() {\n        return this;\n      }())))\n\n      /***/\n    },\n    /* 2 */\n    /***/\n    function(module, exports) {\n\n      'use strict';\n\n      var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) {\n\n        // parse slide data (url, title, size ...) from DOM elements\n        // (children of gallerySelector)\n        var parseThumbnailElements = function parseThumbnailElements(el) {\n          el = el.parentNode.parentNode;\n          var thumbElements = el.getElementsByClassName('thumb'),\n            numNodes = thumbElements.length,\n            items = [],\n            figureEl,\n            linkEl,\n            size,\n            type,\n            // video or not\n            target,\n            item;\n\n          for (var i = 0; i < numNodes; i++) {\n\n            figureEl = thumbElements[i]; //\n\n            // include only element nodes\n            if (figureEl.nodeType !== 1) {\n              continue;\n            }\n\n            linkEl = figureEl.children[0]; //\n\n            size = linkEl.getAttribute('data-size').split('x');\n            type = linkEl.getAttribute('data-type');\n            target = linkEl.getAttribute('data-target');\n            // create slide object\n            item = {\n              src: linkEl.getAttribute('href'),\n              w: parseInt(size[0], 10),\n              h: parseInt(size[1], 10)\n            };\n\n            if (figureEl.children.length > 1) {\n              item.title = figureEl.children[1].innerHTML;\n            }\n\n            if (linkEl.children.length > 0) {\n              item.msrc = linkEl.children[0].getAttribute('src');\n              item.type = type;\n              item.target = target;\n              item.html = '<video src=\"' + target + '\" controls=\"controls\" autoplay=\"autoplay\"></video>';\n              if (type === 'video') {\n                //item.src = null;\n              }\n            }\n\n            item.el = figureEl; // save link to element for getThumbBoundsFn\n            items.push(item);\n          }\n\n          return items;\n        };\n\n        // find nearest parent element\n        var closest = function closest(el, fn) {\n          return el && (fn(el) ? el : closest(el.parentNode, fn));\n        };\n\n        // triggers when user clicks on thumbnail\n        var onThumbnailsClick = function onThumbnailsClick(e) {\n          e = e || window.event;\n          e.preventDefault ? e.preventDefault() : e.returnValue = false;\n\n          var eTarget = e.target || e.srcElement;\n\n          // find root element of slide\n          var clickedListItem = closest(eTarget, function(el) {\n            return el.tagName && el.tagName.toUpperCase() === 'FIGURE';\n          });\n\n          if (!clickedListItem) {\n            return;\n          }\n\n          // find index of clicked item by looping through all child nodes\n          // alternatively, you may define index via data- attribute\n          var clickedGallery = clickedListItem.parentNode,\n\n            // childNodes = clickedListItem.parentNode.childNodes,\n            // numChildNodes = childNodes.length,\n            childNodes = document.getElementsByClassName('thumb'),\n            numChildNodes = childNodes.length,\n            nodeIndex = 0,\n            index;\n\n          for (var i = 0; i < numChildNodes; i++) {\n            if (childNodes[i].nodeType !== 1) {\n              continue;\n            }\n\n            if (childNodes[i] === clickedListItem) {\n              index = nodeIndex;\n              break;\n            }\n            nodeIndex++;\n          }\n\n          if (index >= 0) {\n            // open PhotoSwipe if valid index found\n            openPhotoSwipe(index, clickedGallery);\n          }\n          return false;\n        };\n\n        // parse picture index and gallery index from URL (#&pid=1&gid=2)\n        var photoswipeParseHash = function photoswipeParseHash() {\n          var hash = window.location.hash.substring(1),\n            params = {};\n\n          if (hash.length < 5) {\n            return params;\n          }\n\n          var vars = hash.split('&');\n          for (var i = 0; i < vars.length; i++) {\n            if (!vars[i]) {\n              continue;\n            }\n            var pair = vars[i].split('=');\n            if (pair.length < 2) {\n              continue;\n            }\n            params[pair[0]] = pair[1];\n          }\n\n          if (params.gid) {\n            params.gid = parseInt(params.gid, 10);\n          }\n\n          return params;\n        };\n\n        var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) {\n          var pswpElement = document.querySelectorAll('.pswp')[0],\n            gallery,\n            options,\n            items;\n\n          items = parseThumbnailElements(galleryElement);\n          // define options (if needed)\n          options = {\n\n            // define gallery index (for URL)\n            galleryUID: galleryElement.getAttribute('data-pswp-uid'),\n\n            getThumbBoundsFn: function getThumbBoundsFn(index) {\n              // See Options -> getThumbBoundsFn section of documentation for more info\n              var thumbnail = items[index].el.getElementsByTagName('img')[0],\n                // find thumbnail\n                pageYScroll = window.pageYOffset || document.documentElement.scrollTop,\n                rect = thumbnail.getBoundingClientRect();\n\n              return {\n                x: rect.left,\n                y: rect.top + pageYScroll,\n                w: rect.width\n              };\n            }\n\n          };\n\n          // PhotoSwipe opened from URL\n          if (fromURL) {\n            if (options.galleryPIDs) {\n              // parse real index when custom PIDs are used\n              // http://photoswipe.com/documentation/faq.html#custom-pid-in-url\n              for (var j = 0; j < items.length; j++) {\n                if (items[j].pid == index) {\n                  options.index = j;\n                  break;\n                }\n              }\n            } else {\n              // in URL indexes start from 1\n              options.index = parseInt(index, 10) - 1;\n            }\n          } else {\n            options.index = parseInt(index, 10);\n          }\n\n          // exit if index not found\n          if (isNaN(options.index)) {\n            return;\n          }\n\n          if (disableAnimation) {\n            options.showAnimationDuration = 0;\n          }\n\n          // Pass data to PhotoSwipe and initialize it\n          gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);\n          gallery.init();\n\n          var $tempVideo;\n          var stopVideoHandle = function stopVideoHandle() {\n            if ($tempVideo) {\n              $tempVideo.remove();\n              $tempVideo = null;\n            }\n          };\n          var changeHandle = function changeHandle() {\n            var item = gallery.currItem;\n            stopVideoHandle();\n            if (item.type === 'video') {\n              var $ctn = item.container;\n              var style = $ctn.getElementsByClassName('pswp__img')[0].style;\n              var $video = document.createElement('video');\n              $video.setAttribute('autoplay', 'autoplay');\n              $video.setAttribute('controls', 'controls');\n              $video.setAttribute('src', item.target);\n              $video.style.width = style.width;\n              $video.style.height = style.height;\n              $video.style.position = 'absolute';\n              $video.style.zIndex = 2;\n              $tempVideo = $video;\n              $ctn.appendChild($video);\n            }\n          };\n          gallery.listen('initialZoomIn', changeHandle);\n          gallery.listen('afterChange', changeHandle);\n          gallery.listen('initialZoomOut', stopVideoHandle);\n        };\n\n        // loop through all gallery elements and bind events\n        var galleryElements = document.querySelectorAll(gallerySelector);\n        for (var i = 0, l = galleryElements.length; i < l; i++) {\n          galleryElements[i].setAttribute('data-pswp-uid', i + 1);\n          galleryElements[i].onclick = onThumbnailsClick;\n        }\n\n        // Parse URL and open gallery if it contains #&pid=3&gid=1\n        var hashData = photoswipeParseHash();\n        if (hashData.pid && hashData.gid) {\n          openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true);\n        }\n      };\n\n      var Viewer = function() {\n        function init() {\n          initPhotoSwipeFromDOM('.photos');\n        }\n        return {\n          init: init\n        };\n      }();\n\n      module.exports = Viewer;\n\n      /***/\n    },\n    /* 3 */\n    /***/\n    function(module, exports) {\n\n      /* WEBPACK VAR INJECTION */\n      (function(global) {\n        module.exports = inViewport;\n\n        var instances = [];\n        var supportsMutationObserver = typeof global.MutationObserver === 'function';\n\n        function inViewport(elt, params, cb) {\n          var opts = {\n            container: global.document.body,\n            offset: 0\n          };\n\n          if (params === undefined || typeof params === 'function') {\n            cb = params;\n            params = {};\n          }\n\n          var container = opts.container = params.container || opts.container;\n          var offset = opts.offset = params.offset || opts.offset;\n\n          for (var i = 0; i < instances.length; i++) {\n            if (instances[i].container === container) {\n              return instances[i].isInViewport(elt, offset, cb);\n            }\n          }\n\n          return instances[\n          instances.push(createInViewport(container)) - 1\n            ].isInViewport(elt, offset, cb);\n        }\n\n        function addEvent(el, type, fn) {\n          if (el.attachEvent) {\n            el.attachEvent('on' + type, fn);\n          } else {\n            el.addEventListener(type, fn, false);\n          }\n        }\n\n        function debounce(func, wait, immediate) {\n          var timeout;\n          return function() {\n            var context = this,\n              args = arguments;\n            var callNow = immediate && !timeout;\n            clearTimeout(timeout);\n            timeout = setTimeout(later, wait);\n            if (callNow) func.apply(context, args);\n\n            function later() {\n              timeout = null;\n              if (!immediate) func.apply(context, args);\n            }\n          };\n        }\n\n        // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708\n        var contains = function() {\n          if (!global.document) {\n            return true;\n          }\n          return global.document.documentElement.compareDocumentPosition ?\n            function(a, b) {\n              return !!(a.compareDocumentPosition(b) & 16);\n            } :\n            global.document.documentElement.contains ?\n              function(a, b) {\n                return a !== b && (a.contains ? a.contains(b) : false);\n              } :\n              function(a, b) {\n                while (b = b.parentNode) {\n                  if (b === a) {\n                    return true;\n                  }\n                }\n                return false;\n              };\n        }\n\n        function createInViewport(container) {\n          var watches = createWatches();\n\n          var scrollContainer = container === global.document.body ? global : container;\n          var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15);\n\n          addEvent(scrollContainer, 'scroll', debouncedCheck);\n\n          if (scrollContainer === global) {\n            addEvent(global, 'resize', debouncedCheck);\n          }\n\n          if (supportsMutationObserver) {\n            observeDOM(watches, container, debouncedCheck);\n          }\n\n          // failsafe check, every 200ms we check for visible user\n          // usecase: a hidden parent containing eleements\n          // when the parent becomes visible, we have no event that the children\n          // became visible\n          setInterval(debouncedCheck, 150);\n\n          function isInViewport(elt, offset, cb) {\n            if (!cb) {\n              return isVisible(elt, offset);\n            }\n\n            var remote = createRemote(elt, offset, cb);\n            remote.watch();\n            return remote;\n          }\n\n          function createRemote(elt, offset, cb) {\n            function watch() {\n              watches.add(elt, offset, cb);\n            }\n\n            function dispose() {\n              watches.remove(elt);\n            }\n\n            return {\n              watch: watch,\n              dispose: dispose\n            };\n          }\n\n          function watchInViewport(elt, offset, cb) {\n            if (isVisible(elt, offset)) {\n              watches.remove(elt);\n              cb(elt);\n            }\n          }\n\n          function isVisible(elt, offset) {\n            if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) {\n              return false;\n            }\n\n            // Check if the element is visible\n            // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js\n            if (!elt.offsetWidth || !elt.offsetHeight) {\n              return false;\n            }\n\n            var eltRect = elt.getBoundingClientRect();\n            var viewport = {};\n\n            if (container === global.document.body) {\n              viewport = {\n                top: -offset,\n                left: -offset,\n                right: global.document.documentElement.clientWidth + offset,\n                bottom: global.document.documentElement.clientHeight + offset\n              };\n            } else {\n              var containerRect = container.getBoundingClientRect();\n              viewport = {\n                top: containerRect.top - offset,\n                left: containerRect.left - offset,\n                right: containerRect.right + offset,\n                bottom: containerRect.bottom + offset\n              };\n            }\n\n            // The element must overlap with the visible part of the viewport\n            var visible =\n              (\n                (eltRect.right > viewport.left) &&\n                (eltRect.left < viewport.right) &&\n                (eltRect.bottom > viewport.top) &&\n                (eltRect.top < viewport.bottom)\n              );\n\n            return visible;\n          }\n\n          return {\n            container: container,\n            isInViewport: isInViewport\n          };\n        }\n\n        function createWatches() {\n          var watches = [];\n\n          function add(elt, offset, cb) {\n            if (!isWatched(elt)) {\n              watches.push([elt, offset, cb]);\n            }\n          }\n\n          function remove(elt) {\n            var pos = indexOf(elt);\n            if (pos !== -1) {\n              watches.splice(pos, 1);\n            }\n          }\n\n          function indexOf(elt) {\n            for (var i = watches.length - 1; i >= 0; i--) {\n              if (watches[i][0] === elt) {\n                return i;\n              }\n            }\n            return -1;\n          }\n\n          function isWatched(elt) {\n            return indexOf(elt) !== -1;\n          }\n\n          function checkAll(cb) {\n            return function() {\n              for (var i = watches.length - 1; i >= 0; i--) {\n                cb.apply(this, watches[i]);\n              }\n            };\n          }\n\n          return {\n            add: add,\n            remove: remove,\n            isWatched: isWatched,\n            checkAll: checkAll\n          };\n        }\n\n        function observeDOM(watches, container, cb) {\n          var observer = new MutationObserver(watch);\n          var filter = Array.prototype.filter;\n          var concat = Array.prototype.concat;\n\n          observer.observe(container, {\n            childList: true,\n            subtree: true,\n            // changes like style/width/height/display will be catched\n            attributes: true\n          });\n\n          function watch(mutations) {\n            // some new DOM nodes where previously watched\n            // we should check their positions\n            if (mutations.some(knownNodes) === true) {\n              setTimeout(cb, 0);\n            }\n          }\n\n          function knownNodes(mutation) {\n            var nodes = concat.call([],\n              Array.prototype.slice.call(mutation.addedNodes),\n              mutation.target\n            );\n            return filter.call(nodes, watches.isWatched).length > 0;\n          }\n        }\n\n        /* WEBPACK VAR INJECTION */\n      }.call(exports, (function() {\n        return this;\n      }())))\n\n      /***/\n    }\n    /******/\n  ]);\n","count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\">&#39; + data.year + &#39;&#39; + data.month + &#39;月</span></a></li></ol>","data":[]}